@ai[2025-10-16 00:20] 目的: コンテキスト崩壊を防ぎ、共有知の単一化と検証可能な更新履歴を確保する。

## フロー概要
1. **Reflector**: 振り返りを行い、共有すべき変更点を抽出する。
2. **Curator**: Reflector出力を精査し、追加・修正・削除の指示（JSON）を作成、SQLiteに登録する。
3. **Updator**: SQLiteから未適用の指示を取得し、`docs/project-context.md`へ反映、適用済みフラグを更新する。

## 各エンジニアの作業内容

### Reflector（ソクラテス）の作業
#### 振り返り指針
- **事実と推測を明確に分離**: 観察された事実と解釈・推測を区別して記録
- **共有価値の高い情報を優先**: チーム全体の学習・効率化に寄与する情報を重視
- **既存コンテキストの矛盾・重複を検出**: 現在の知識ベースとの整合性を確認
- **問いかけによる深掘り**: 表面的な情報ではなく、なぜ・どのように・何を学んだかを探求

#### 出力テンプレート
- **追加候補**: 新しく発見した知識・パターン、将来参照すべき重要な決定事項
- **修正候補**: 既存情報の不正確・不完全な部分、より適切な表現・分類への変更提案
- **削除候補**: 古くなった・不要になった情報、重複・冗長な内容

### Curator（デューイ）の作業
#### 検証プロセス
1. **入力検証**: Reflectorの出力が要件を満たしているか確認
2. **論理検証**: 提案内容の論理的整合性をチェック
3. **構造化**: 標準フォーマット（JSON）への変換
4. **データベース整合性**: 既存データとの競合・重複チェック
5. **実行可能性**: 指示の実装可能性とリスク評価

#### 指示(JSON)フォーマット仕様
```json
{
  "op": "add|update|delete",
  "title": "更新内容の簡潔なタイトル",
  "content": "具体的な更新内容",
  "created_at": 整数値 //"エポック時刻(ms)"
}
```

#### データベース登録ルール
- `db/context_updates.sqlite` の `instructions` テーブルに登録
- `applied` フィールドは初期値0（未適用）
- 重複チェック: 同一セクションへの同時更新は禁止
- トランザクション: 複数指示は原子性を保証

### Updator（ターミネーター）の作業
#### 実行プロセス
1. **事前チェック**: 未適用指示の存在確認と実行可能性検証
2. **バックアップ**: 現在のファイル状態の保存
3. **順次実行**: ID昇順での指示適用（原子性保証）
4. **検証**: 各適用後の整合性チェック
5. **ロールバック**: エラー時の自動復旧
6. **ログ記録**: 実行結果の詳細記録

#### 実装要件
- **失敗時はロールバック**: エラー発生時は即座に前状態に復元
- **適用順はID昇順**: データベースの登録順序を厳守
- **セクション操作は見出し単位**: Markdownの見出し（# ...）を基準とした操作
- **原子性保証**: 全指示の成功または全失敗

#### セクション操作ルール
- **add**: セクションが存在しない場合は末尾に追加
- **update**: 既存セクションの完全置換（見出しは維持）
- **delete**: セクション全体の削除（見出し含む）

## SQLite スキーマ
```sql
CREATE TABLE IF NOT EXISTS instructions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  op TEXT NOT NULL CHECK(op IN ('add','update','delete')),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  applied INTEGER NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL
);
```

## 参考
インスピレーション元動画: [`YouTube`](https://www.youtube.com/watch?v=PWOJ0QANGsA)

